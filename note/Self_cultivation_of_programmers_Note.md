# 硬件结构
南桥芯片：磁盘、usb、键盘、鼠标等低速设备
北桥芯片：高速设备

# CPU
## 多道程序(Multiprogramming) 
当某个程序暂时无法使用CPU时，监控程序把另外在等待CPU资源的程序启动，使得CPU能够充分利用起来。

## 分时系统(Time-Sharing System) 
每个程序运行一段时间后都主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一小段时间。(系统中任何一个程序死循环都会导致系统死机)
## 多任务系统(Multi-tasking)
操作系统接管所有的硬件资源，本身运行在一个受硬件保护的级别，所有的应用程序都以进程(Process)的方式运行在比操作系统权限更低的级别，每个进程有自己的独立地址空间，使得进程之间的地址空间相互隔离。

## 抢占式(Preempitve)
CPU有操作系统进行统一进行分配，每个进程根据进程优先级的高低都有机会获得CPU,运行一段时间后，操作系统暂停该进程，将CPU资源分配给其他等待运行的进程。

# 内存
## 分段(Segmentation)
虚拟内存与物理内存一一映射，比如操作系统来设置这个映射函数，实际的地址转换由硬件完成。
## 分页(Paging)
虚拟页、物理页、磁盘页、页错误(page fault)
在页映射模式下，CPU发出的是virtual address，经过MMU(Memory Management Unit)转换以后变成physical address。一般MMU都集成在CPU内部。


# 线程
线程数量小于等于处理器数量时，线程的并发是真正的并发。线程的数量大于处理器数量的情况下，线程的并发是一种模拟出来的状态。操作系统会让这些多线程程序轮流执行，每次执行一小段时间(几十到几百毫秒)。这样的一个不断在处理器上切换不同线程的行为称之为线程调度(Thread Schedule)。

线程至少拥有三种状态：
运行(Running)   线程正在执行。
就绪(Ready)     此时线程可以立刻运行，但CPU已经被占有。
等待(Waiting)   线程正在等待某一事件(通常是I/O或同步)发生，无法执行。

IO密集型线程(IO Bound Thread)   频繁等待的线程
CPU密集型线程(CPU Bound Thread)     很少等待的线程

饿死(Starvation): 该线程优先级较低，始终无法执行。

## 线程安全
### 竞争与原子操作
自增(++)操作在多线程环境下会出现错误是应为这个操作被编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断，去执行别的代码。

我们把单指令的操作称为原子的(Atomic)，无论如何，单条指令是不会被打断的。
#### 可重入(Reentrant)
函数还没有执行完，在此被调用。
#### 过度优化
编译器对代码的过度优化，导致执行顺序与代码不一致。

## 线程内部情况
内核线程与用户态线程并不一样
一对一、一对多、多对多


# 进程
写时复制(Copy on Write,COW),指的是两个任务可以同时自由地读取内存，但任意方面试图修改内存时，内存就会复制一份提供给修改方使用，以免影响其他的任务使用。


# 编译和链接
预处理(Prepressing)、编译(Compilation)、汇编(Assembly)和链接(Linking)
## 预编译
gcc -E hello.c -o hello.i
处理源代码中的以“#”开始的预编译指令。

## 编译
gcc -S hello.i -o hello.s

## 汇编
gcc -c hello.s -o hello.o

## 链接

## 编译器
### 词法分析
扫描器(Scanner)-->词法分析-->有限状态机(Finite State Machine)算法-->代码的字符序列分割成一系列的记号(Token)-->lex
### 语法分析
语法分析器(Grammar Parser)-->扫描器产生的记号进行语法分析-->生成语法树(Syntax Tree)-->yacc
整个过程采用了上下文无关语法(Context-free Grammar)的分析手段。
语法分析器生成的语法树就是以表达式(Expression)为节点的树。
### 语义分析
语义分析器(Semantic Analyzer)
静态语义(Static Semantic)   编译期可以确定的语义(声明和类型转换)
动态语义(Dynamic Semantic)  运行期才可以确定的语义(0作为除数)
### 中间语言生成
源码级优化器(Source Code Optimizer) (2+6可优化)
### 目标代码生成与优化
代码生成器(Code Generator)和目标代码优化器(Target Code Optimizer)。

## 链接器
地址和空间分配、符号决议和重定向