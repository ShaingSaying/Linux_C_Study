# 词法分析器flex
crtl+D unix/linux的文件结束符。
在没有任何改变的情况下，词法分析器将读取标准输入。
## yytext
在任意一个flex的动作中，变量yytext总是被设为指向本次匹配的输入文本。
## yylex()
大多数包含flex词法分析器的程序使用**词法**分析器来获得一个记号流，这样可以方便**语法**分析器的处理。

当程序需要一个记号时，它调用yylex()来读取一小部分输入然后返回相应的记号。

在词法分析器中，当动作代码识别出一个记号时，yylex()将以这个记号作为返回值。当程序再次调用yylex()时，词法分析器会以后续的输入字符继续分析。
## 记号编号和记号值

当flex词法分析器返回一个记号流时, 每个记号实际上有两个组成部分，**记号编号(token number)**和**记号值(token's value)**。

记号编号是一个较小的整数。这个数字是随机确定的，但是**零值总是意味着文件的结束**。

当bison创建一个语法分析器时，bison自动地从258(避免与文字字符记号产生冲突)起指派每个记号编号，并且创建一个包含这些编号定义的.h文件。

## yylval
yylval这个变量用来存储记号值，(记号值通常被定义为联合类型以便于不同类型的记号可以拥有不同类型的记号值)

# 语法分析器bison
bison会自动帮你分析语法，记住每条被匹配的规则，所以动作代码只需要维护每个语法符号关联的语义值。

每个bison规则中的语法符号都有一个语义值，**目标符号**(冒号左边的语法符号)的值在动作中用代码$$代替，冒号右边语法符号的语义值依次为$1、$2，直到这条规则的结束。

当词法分析器返回记号时，记号值总是存储在yyval里，其他语法符号的语义值则在语法分析器的规则里进行设置。

# flex
任何flex词法分析器都使用了强大的正则表达式语言。正则表达式使用元语言来描述你想匹配的模式。
## 正则表达式
.
[]              字符类，可以匹配方括号中的任意一个字符。
[a-z]{-}[jv]
^               如果它是正则表达式的第一个字符就匹配行首。
$               如果它是正则表达式的最后一个字符就匹配行尾。
{}              当花括号中带有一个或两个数字时，它表示前一个模式可以匹配的最小和最大次数。例如：A{1,3}匹配一到三个字母A, 0{5}匹配00000。
\               用来表示元字符自身和一部分常用的C语言转义序列。
*               匹配0个或者多个紧接在前面的表达式。
+               匹配1个或者多个紧接在前面的表达式。
?               匹配0个或者1个紧接在前面的表达式。例如，-?[0-9]+
|               选择操作符，匹配紧接在前面的表达式或者紧跟在后面的表达式。
"..."           所有引号中的字符将基于字面意义被解释。
()              把一系列的正则表达式组成一个新的正则表达式。a(bc|de)匹配abc或者ade
/               尾部上下文，匹配斜线前的正则表达式，但是要求其后紧跟着斜线后的表达式。例如，0/1匹配字符串01中的0，但是不会匹配字符串0或者02。
## 二义性
flex通过两个简单的规则来解决二义性：
1. 词法分析器匹配输入时匹配**尽可能多**的字符串。
2. 如果两个模式都可以匹配的话，匹配在程序中**更早出现**的模式。
## Flex词法分析器中的文件I/O操作
## 输入
除非你另做安排，否则词法分析器**总是通过名为yyin的文件句柄读取输入。**否则，yyin将保持未赋值的状态，这种情况下，yylex会自动把stdin赋给它。

一般只需要在第一次调用yylex之前重新设定yyin。

flex提供了yyrestart(FILE* f)它使用词法分析器读取标准输入输出文件f。

flex的输入管理的三个层次是：
1. 设置yyin来读取所需文件
2. 创建并使用YY_BUFFER_STATE输入缓冲区
3. 重定义YY_INPUT

## 输出
出发另行设定，否则flex总会执行一条默认的规则：所有没有被匹配的输入都拷贝到yyout。

# Bison
## 移进/规约分析
当语法分析器读取记号时，每当它读到的记号无法结束一条规则时，它将把这个记号压入一个内部堆栈。然后切换到一个新状态，这个状态能够反映出刚刚读取的记号。这种行为叫做移进(shift)。

当它发现压入的所有语法符号已经可以组成规则的右部时，它将把右部符号全部从堆栈中弹出，然后把左部语法符号压入堆栈。这种行为叫做规约(reduction)，它通常消减堆栈中一定数量的符号。

每当bison规约一条规则时，他会执行该规则关联的用户代码。

## 两种分析方法
bison语法分析器可以使用两种分析方法，一种是LALR(1)(自左向右向前查看一个记号)，另一种是GLR(通用的自左向右)。大多数语法分析器使用LRLR(1)，它不如GLR强大但是被认为比GLR更快和更容易使用。
