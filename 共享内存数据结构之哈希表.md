>最近在学习大神同事hxw的代码设计，再此做一个总结。

# 共享内存哈希表结构体设计
共享内存哈希表的设计借助的静态链表的思想，建议先研究了解一下静态链表:
1. [[读书笔记]-大话数据结构-3-线性表(三)-静态链表、循环链表和双向链表](https://www.cnblogs.com/zhaoxy/p/7754906.html)
2. [静态链表的C实现和核心点(基于数据结构 严蔚敏)](https://www.cnblogs.com/zrj-xjyd/p/8735145.html)

静态链表的优缺点：

1. 优点：再插入和删除时候，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。
2. 缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。

![共享内存哈希表原理与结构体设计](共享内存哈希表.jpg)
```c
/* 哈希节点 */
typedef struct hash_node_s hash_node_t;
struct hash_node_s
{
    unsigned int node_index;    /* 链表节点index */
};

/* 链表节点个数 */
typedef struct list_node_s list_node_t;
struct list_node_s
{
    unsigned int next;     /* 下一个节点index */
    unsigned int key;      /* key的index */
    unsigned int val;      /* val的index */
}

/* 静态内存哈希表头结构信息 */
typedef struct mem_hash_s mem_hash_t;
struct mem_hash_s
{
    unsigned int mem_size;      /* 内存总大小 */
    unsigned int hash_size;     /* 哈希节点个数 */
    unsigned int list_size;     /* 链表节点个数 */
    unsigned int key_size;      /* key大小 */
    unsigned int val_size;      /* val大小 */
    /* node_size = sizeof(list_node_t) + key_size + val_size */
    unsigned int node_size;     /* 链表节点大小 */
    unsigned int free_index;    /* 空闲的链表头节点index */

    unsigned int hash_head;     /* 哈希头节点index */
    unsigned int list_head;     /* 链表头节点index */
}

/* 迭代器 */
typedef struct mem_hash_iterator_s mem_hash_iterator_t;
struct mem_hash_iterator_s
{
    unsigned int hash_num;      /* 当前哈希节点 */
    unsigned int node_next;     /* 下一个链表节点 */
}
```

# 哈希函数
哈希函数采用的是Redis里使用的经典Times 33哈希算法。又叫DJBX33A，Bernstein's hash。该算法由Daniel J. Bernstein教授多年前在comp.lang.c发表。它是有史以来发布的最有效的哈希函数之一。
关于该算法的更多了解：
1. [经典的Times 33 哈希算法](https://zhanjia.iteye.com/blog/2426782?utm_medium=referral)
2. [HASH表](https://my.oschina.net/myspaceNUAA/blog/68241)
```c
/* Generic hash function (a popular one from Bernstein).
 * I tested a few and this was the best. */
unsigned int dict_gen_hash_function(const unsigned char *buf, int len)
{
    unsigned int hash = 5381;

    while (len--)
        hash = ((hash << 5) + hash) + (*buf++); /* hash * 33 + c */
    return hash;
}
```
# 使用接口设计
## mem_hash_init 初始化
由共享内存开辟可知，共享内存哈希表为静态的，大小需要由具体问题提前决定。
需要确定的参数有:**mem_size, hash_size, key_size, val_size**。

且**mem_size >= (sizeof(mem_hash_t) + sizeof(hash_node_t) * hash_size +  (sizeof(list_node_t)+ key_size + val_size) * hash_size)**;

初始化分三步：
1. 初始化mem_hash_t结构体
2. 初始化hash_node_t结构体
3. 初始化list_node_t结构体
```c
/* 初始化 */
int mem_hash_init(mem_hash_t *mem_hash, unsigned int mem_size, unsigned int hash_size, unsigned int key_size, unsigned int val_size)
{
    int num = 0;
    int node_num = 0;
    unsigned int min_mem_size = 0;
    unsigned int list_node_size = 0;
    unsigned int list_head_tmp = 0;
    hash_node_t *hash_node_tmp = NULL;
    list_node_t *list_node_tmp = NULL;

    /* 入参检查 */
    if(NULL == mem_hash)
    {
        printf("mem_hash is NULL\n");
        return -1;
    }
    if(MIN_HASH_SIZE > hash_size)
    {
        printf("hash_size must bigger then %d\n", MIN_HASH_SIZE);
        return -1;
    }
    if(0 >= key_size || 0 >= val_size)
    {
        printf("key_size or val_size error\n");
        return -1;
    }

    list_node_size = sizeof(list_node_t) + key_size + val_size;
    min_mem_size = sizeof(mem_hash_t) + sizeof(hash_node_t) * hash_size +  list_node_size * hash_size;
    if(min_mem_size > mem_size)
    {
        printf("mem_size must bigger then %d", min_mem_size);
        return -1;
    }

    mem_hash->mem_size = mem_size;
    mem_hash->hash_size = hash_size;
    mem_hash->key_size = key_size;
    mem_hash->val_size = val_size;
    mem_hash->node_size = list_node_size;

    mem_hash->free_index = sizeof(mem_hash_t) + sizeof(hash_node_t) * hash_size;
    mem_hash->hash_head = sizeof(mem_hash_t);
    mem_hash->list_head = sizeof(mem_hash_t) + sizeof(hash_node_t) * hash_size;

    /* 初始化哈希节点 */
    /* 将哈希节点赋值为空 */
    for(num = 0; num < hash_size; num++)
    {
        hash_node_tmp = (hash_node_t *)((char *)mem_hash + mem_hash->hash_head + sizeof(hash_node_t) * num);
        hash_node_tmp->node_index = LIST_EMPTY;
    }

    /* 初始化链表节点 */
    node_num = 0;
    list_head_tmp = mem_hash->list_head;
    while(1)
    {
        node_num++;
        list_node_tmp = (list_node_t *)((char *)mem_hash + list_head_tmp);
        list_node_tmp->next = list_head_tmp + mem_hash->node_size;
        list_node_tmp->key = list_head_tmp + sizeof(list_node_t);
        list_node_tmp->val = list_node_tmp->key + mem_hash->key_size;
        /* 循环初始化链表结构 */
        if((list_head_tmp + mem_hash->node_size) < mem_hash->mem_size)
        {
            list_head_tmp += mem_hash->node_size;
        }
        else
        {
            break;
        }
    }
    /* 最后一个节点 */
    list_node_tmp->next = LIST_EMPTY;
    /* 初始化最后的结构就是获取链表个数 */
    mem_hash->list_size = node_num;

    return 0;
}
```
## mem_hash_add 添加key-value
添加元素时
1. 注意:存储key-value的大小一定要与结构体设计初始化时的大小一样。
2. 添加元素到free指针指向的空间list_node_t中，偏移free指针，返回添加元素的相对于头部的偏移位置。
3. 通过key计算该位置存储的哈希位置
    1. 如果该哈希位置的节点存储为空，则直接存入
    2. 如果该哈希位置的节点存储不为空，则遍历该位置的next位置，直到为空，处链接该位置。
4. 将存入key和val的节点相对于头部的偏移位置赋予哈希表的节点位置
```c
int mem_hash_add(mem_hash_t *mem_hash, char *key, unsigned int key_size, char *val, unsigned int val_size)
{
    int ret = -1;
    unsigned int node_index = 0;
    /* 入参检测 */
    if(NULL == mem_hash || NULL == key || NULL == val)
    {
        printf("param is NULL\n");
        return -1;
    }
    /* 入参检测key和val的大小一定要与结构体设计的大小一样 */
    if(key_size != mem_hash->key_size || val_size != mem_hash->val_size)
    {
        printf("size error, key_size:%u, val_size:%u\n", key_size, val_size);
        return -1;
    }

    /* 获取一个链表节点 */
    /* 将key和val存入list_node中,返回的是位置相对头的偏移位置 */
    node_index = node_init(mem_hash, key, val);
    if(LIST_EMPTY == node_index)
    {
        printf("node_init error\n");
        return -1;
    }

    /* 插入哈希表 */
    /* 将存入key和val的节点相对于头部的偏移位置赋予哈希表的节点位置 */
    ret = hash_add(mem_hash, key, node_index);
    if(0 != ret)        /* 当前只有返回值0 */
    {
        /* 异常则回收链表节点 */
        node_release(mem_hash, node_index);
    }
    return 0;
}
```

## mem_hash_delete 删除
```c
int mem_hash_delete(mem_hash_t *mem_hash, char *key, unsigned int key_size)
{
    int ret = -1;
    unsigned int node_index = 0;
    if(NULL == mem_hash || NULL == key)
    {
        printf("param is NULL\n");
        return -1;
    }
    if(key_size != mem_hash->key_size)
    {
        printf("size error, key_size:%u\n", key_size);
        return -1;
    }

    /* 从哈希表剔除链表节点 */
    ret = hash_delete(mem_hash, key, &node_index);
    if(0 != ret)
    {
        printf("hash_delete error\n");
        return ret;
    }

    /* 回收链表节点 */
    node_release(mem_hash, node_index);

    return 0;
}
```

## mem_hash_find 查找且返回val值
```c
int mem_hash_find(mem_hash_t *mem_hash, char *key, unsigned int key_size, char *val, unsigned int val_size)
{
    int ret = -1;
    unsigned int node_index = 0;
    list_node_t *list_node = NULL;

    if(NULL == mem_hash || NULL == key || NULL == val)
    {
        printf("param is NULL\n");
        return -1;
    }
    if(key_size != mem_hash->key_size || val_size != mem_hash->val_size)
    {
        printf("size error, key_size:%u, val_size:%u\n", key_size, val_size);
        return -1;
    }
    /* 从哈希表查找链表节点 */
    ret = hash_find(mem_hash, key, &node_index);
    if(0 != ret)
    {
        printf("hash_find error\n");
        return ret;
    }
    else
    {
        list_node = (list_node_t *)((char *)mem_hash + node_index);
        memcpy(val, (char *)mem_hash + list_node->val, mem_hash->val_size);
    }
    return 0;
}
```

## mem_hash_get_iterator 建立迭代器
```c
mem_hash_iterator_t* mem_hash_get_iterator(mem_hash_t *mem_hash)
{
    hash_node_t *hash_node_tmp = NULL;
    hash_node_tmp = (hash_node_t *)((char *)mem_hash + mem_hash->hash_head);

    mem_hash_iterator_t *itr = (mem_hash_iterator_t *)malloc(sizeof(mem_hash_iterator_t));
    if(NULL == itr)
    {
        printf("mem_hash_iterator_t malloc error\n");
        return NULL;
    }

    itr->hash_num = 0;
    itr->node_next = hash_node_tmp->node_index;

    return itr;
}
```
## mem_hash_next 迭代返回元素
```c
int mem_hash_next(mem_hash_t *mem_hash, mem_hash_iterator_t *itr, unsigned int *node_index)
{
    int ret = -1;
    unsigned int current_index = 0;
    hash_node_t *hash_node_tmp = NULL;
    list_node_t *list_node_tmp = NULL;

    if(NULL == mem_hash || NULL == itr || NULL == node_index)
    {
        printf("param is NULL\n");
        return -1;
    }

    current_index = itr->node_next;
    while(1)
    {
        printf("hash_num:%u, current_index:%u\n", itr->hash_num, current_index);
        if(LIST_EMPTY == current_index)
        {
            /* 下一个哈希链表 */
            itr->hash_num++;
            if(itr->hash_num >= mem_hash->hash_size)
            {
                break;
            }
            hash_node_tmp = (hash_node_t *)((char *)mem_hash + mem_hash->hash_head + sizeof(hash_node_t) * (itr->hash_num));
            current_index = hash_node_tmp->node_index;
        }
        else
        {
            /* 返回当前链表节点 */
            list_node_tmp = (list_node_t *)((char *)mem_hash + current_index);
            /* 迭代器指向下一个链表节点 */
            itr->node_next = list_node_tmp->next;
            
            break;
        }
    }
    if(itr->hash_num == mem_hash->hash_size && LIST_EMPTY == current_index)
    {
        printf("mem_hash fetch end\n");
        return -1;
    }
    else
    {
        *node_index = current_index;
        return 0;
    }
}
```