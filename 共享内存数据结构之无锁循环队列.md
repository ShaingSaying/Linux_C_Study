
# 共享内存无锁循环队列结构体设计
![共享内存无锁循环队列结构体设计](共享内存无锁循环队列.jpg)
```c
typedef struct shm_queue_s shm_queue_t;
struct shm_queue_s
{
    //int shm_id;
    int read_index;
    int write_index;
    int queue_len;
};
```
# 队列使用原理
在存取数据时，首先对数据长度进行存取。

将数据长度格式化为固定格式的字符串。

先存取长度，在存取数据。

```c
#define LEN_LEN 6
#define LEN_FORMAT "%06d"
char s_len[LEN_LEN + 1];
snprintf(s_len, sizeof(s_len), LEN_FORMAT, buff_len);
```
## 异常处理
队尾长度不足数据长度时，分段存储读取数据。

# 循环队列特性
## 归一化操作
```c
shm_queue->write_index(新的) = (shm_queue->write_index(上一次) + data_len) % shm_queue->queue_len;

shm_queue->read_index(新的) = (shm_queue->read_index(上一次) + data_len) % shm_queue->queue_len;
```
## 队列空
```c
shm_queue->write_index == shm_queue->read_index
```

## 队列剩余空间
```c
free_len = shm_queue->write_index >= shm_queue->read_index ? (shm_queue->queue_len - shm_queue->write_index + shm_queue->read_index) : (shm_queue->read_index - shm_queue->write_index) ;
```

## 队列满
```c
buff_len(数据长度) + LEN_LEN(元数据长度) >= free_len
```

# 无锁原子操作API
## legacy GCC __sync
type __sync_lock_test_and_set(type*ptr,type value,...)

## C++11
[内存模型](http://blog.jobbole.com/106516/)

bool __atomic_test_and_set(void*ptr,intmemorder);

# 接口设计
## init_shm_queue

## is_shm_queue_empty

## get_shm_queue_free_len

## en_shm_queue

## de_shm_queue